# STD imports
import sys
from pathlib import Path
from importlib import import_module
import shutil
import subprocess

# External imports
try:
    from mypy.stubgen import parse_options, generate_stubs
except ImportError:
    print("Please install mypy using  \"pip install mypy\" to generate pyi stub files for libraries generated by pybind11.")
    exit(0)


def __AddSubmodules(output_path: Path):
    if output_path.is_dir():
        with open(str(output_path / "__init__.pyi"), "a") as file_output:
            file_output.write("\n\n#   ---- start of includes of sub modules --- \n\n")

            for cpp_sub_module_path in output_path.iterdir():
                if cpp_sub_module_path.is_dir():
                    cpp_sub_module_name = str(cpp_sub_module_path.relative_to(cpp_sub_module_path.parent))
                else:
                    cpp_sub_module_name = str(cpp_sub_module_path.relative_to(cpp_sub_module_path.parent))[:-4]
                if cpp_sub_module_name != "__init__":
                    file_output.write("from . import {:s}\n".format(cpp_sub_module_name))

            file_output.write("\n#   ---- end of includes of sub modules --- \n\n")

        for cpp_sub_module_path in output_path.iterdir():
            __AddSubmodules(cpp_sub_module_path)


def __GenerateStubFilesForModule(
        kratos_library_path: Path,
        output_path: Path,
        cpp_module_name: str) -> None:
    args = ["-o", str(output_path.absolute()), "-p", cpp_module_name]
    options = parse_options(args)
    generate_stubs(options)

    # if sub modules are found, include them in the __init__.pyi
    submodule_path = kratos_library_path / cpp_module_name
    __AddSubmodules(submodule_path)

    return cpp_module_name


def __MoveGeneratedStub(source: Path, destination: Path) -> None:
    """ Kratos applications consist of python modules and a binary package.
        The binary is imported in the application initializer and directly
        acts as part of the package (not a subpackage). However, the binaries
        are on a nonstandard path and not within the application's module
        => the generated stubs need to be moved and renamed to emulate the
           runtime layout of the application.

        The problem is that this solution shadows everything defined in python,
        so only symbols from the binaries get hints. @todo matekelemen
    """
    items = [p for p in source.glob("*")]
    if len(items) == 1:
        if items[0].is_dir(): # binary package has no subpackages
            for item in items[0].glob("*"):
                if item.is_dir():
                    shutil.copytree(str(item), str(destination / item.name))
                else:
                    shutil.move(str(item), str(destination / item.name))
        else: # binary package has subpackages
            shutil.move(str(items[0]), str(destination / "__init__.pyi"))
    else:
        raise RuntimeError(f"Expecting one generated path, but got {items}")


def Main():
    print("--- Generating python stub files from {:s}".format(sys.argv[1]))
    kratos_installation_path = (Path(sys.argv[1])).absolute()
    kratos_library_path = (kratos_installation_path / "libs").absolute()
    sys.path.insert(0, str(kratos_installation_path.absolute()))
    sys.path.insert(0, str(kratos_library_path.absolute()))

    list_of_cpp_libs = []

    # generate Kratos core cpp stubs files
    list_of_cpp_libs.append(__GenerateStubFilesForModule(kratos_library_path, kratos_library_path, "Kratos"))

    # Collect Kratos applications
    from KratosMultiphysics.kratos_utilities import GetListOfAvailableApplications
    list_of_available_applications = GetListOfAvailableApplications()

    # Generate stubs for all installed applications
    for application_name in list_of_available_applications:
        # Import the application
        import_module("KratosMultiphysics." + application_name)
        application_lib_name = "Kratos" + application_name

        # Generate stubs to temporary directory
        list_of_cpp_libs.append(__GenerateStubFilesForModule(kratos_library_path, kratos_library_path, application_lib_name))

    # now iterate through auxiliary libraries and generate stub files
    for custom_library_path in kratos_library_path.iterdir():
        if custom_library_path.is_file():
            custom_library_name = str(custom_library_path.relative_to(custom_library_path.parent))
            cpython_location = custom_library_name.find(".cpython")
            if cpython_location != -1:
                custom_library_name = custom_library_name[:cpython_location]
                if custom_library_name not in list_of_cpp_libs:
                    list_of_cpp_libs.append(__GenerateStubFilesForModule(kratos_library_path, kratos_library_path, custom_library_name))


if __name__ == "__main__":
    if "--quiet" in sys.argv: # suppress output from Kratos imports
        args = [arg for arg in sys.argv if arg != "--quiet"]
        subprocess.run([sys.executable] + args, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    else:
        Main()
